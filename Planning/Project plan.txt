Примитивный протитип мессенджера попробуем.
Есть пользователи.
Пользователи проходят регистрацию, получают каким-то образом логин/пароль.
Для работы пользователь должен пройти аутентификацию.
Чаты. Любой пользователь может любому пользователю написать.
Любой пользователь может просматривать свои чаты, видеть, какие сообщения он уже просматривал.
Пользователь может искать пользователя по каким-либо параметрам.
Пользователи могут состоять в отношениях (друзья).

Пользователи могут ограничить получение сообщений только от друзей. Любой пользователь может любому пользователю отправить запрос на дружбу. Любой пользователь любого может забанить.

Нужно архитектурно подумать, как такой проект реализовать. О мгновенных сообщениях пока речи не идёт (не нужно сразу всякие message bus'ы юзать).

Какие компоненты нужны? Какие сервисы будут? Какой будет структура API, какие будут контроллеры и с какими action'ами?

Также нужно продумать структуру сущностей для БД.
Не забывать, что проект может начать расти в будущем, могут появиться новые требования к функционалу, например, не только чаты, но и комнаты с несколькими пользователями и админами чата. Появиться могут, но необязательно. 
Фронтом в итоге может оказаться что угодно: мобильное приложение, сторонний сервис, десктопное приложение, веб-приложение.

Нужно иметь общее представление о REST, об HTTP (глаголы, заголовки, тела), о JSON (или об XML), аутентификации с помощью токенов/заголовков.
Затем — об архитектурном паттерне MVC: за что отвечают модели, за что — представления, за что — контроллеры.
Потом — routing (маршрутизация), дефолтная в MVC которая. Надо разобраться, как именно приложение понимает, что если в URL примерно такое: http://host/somecont/doit/, то POST-запрос на такой адрес будет перенаправлен на контроллер с именем SomecontController в метод Doit, который помечен атрибутом [HttpPost]. Ну либо на другое, если используются атрибуты [Route].
Потом нужно определиться с идеологией формата сообщений. Тут единого мнения нет. 


В сторону services.AddAuthentication и его аргументов. Потом .AddScheme с кастомными хендлерами. Потом
.AddScheme<AuthenticationSchemeOptions, MyAwesomeCustomAuthenticationHandler>("название_схемы", opts => {});
MyAwesomeCustomAuthenticationHandler нужно реализовать от AuthenticationHandler<AuthenticationSchemeOptions>, в котором реализовать метод HandleAuthenticateAsync.
Внутри HandleAuthenticateAsync есть доступ к Request, поэтому ты спокойно можешь получить данные из запроса (токен из заголовков, например).
Как разберёшься с аутентификацией и клеймами и HttpContext.User, нужно разобраться с авторизацией. Желательно попробовать и role based authorization, и более обобщённую claims based authorization. Ну и свои политики для опыта поделать (authorization policies).

Если голова закипит и нужно будет на другое переключиться, глянь IUserRepository. Таких интерфейсов будет куча. Может, имеет смысл сделать базовый генерик интерфейс с базовой абстрактной реализацией? Сократит кучу повторяющегося кода. 